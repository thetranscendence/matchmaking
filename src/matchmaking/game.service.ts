import { Service } from 'my-fastify-decorators';
import { Resilient } from './decorators/resilient.decorator.js';
import { ValidateResult } from './decorators/validate.decorator.js';

// =============================================================================
// SCHEMA DEFINITIONS
// =============================================================================

/**
 * TypeScript type for successful game creation.
 * Returned by the Game Service when the game is successfully created (HTTP 201).
 */
export interface CreateGameSuccessDto {
	success: true;
	gameId: string;
	message: string;
}

/**
 * TypeScript type for failed game creation.
 * Returned by the Game Service when creation fails (HTTP 409).
 *
 * Error codes:
 * - GAME_ALREADY_EXISTS: A game with this ID already exists
 * - PLAYER_ALREADY_IN_GAME: One of the players is already in an active game
 * - INVALID_PLAYERS: Invalid player IDs provided
 */
export interface CreateGameErrorDto {
	success: false;
	error: 'GAME_ALREADY_EXISTS' | 'PLAYER_ALREADY_IN_GAME' | 'INVALID_PLAYERS';
	message: string;
}

/**
 * TypeScript union type for all possible responses.
 * Use discriminated union pattern to narrow the type.
 */
export type CreateGameResponseDto = CreateGameSuccessDto | CreateGameErrorDto;

/**
 * JSON Schema for successful game creation response.
 */
const CreateGameSuccessSchema = {
	type: 'object',
	properties: {
		success: { type: 'boolean', const: true },
		gameId: { type: 'string', minLength: 1 },
		message: { type: 'string' },
	},
	required: ['success', 'gameId', 'message'],
	additionalProperties: true,
};

/**
 * JSON Schema for failed game creation response.
 */
const CreateGameErrorSchema = {
	type: 'object',
	properties: {
		success: { type: 'boolean', const: false },
		error: {
			type: 'string',
			enum: ['GAME_ALREADY_EXISTS', 'PLAYER_ALREADY_IN_GAME', 'INVALID_PLAYERS'],
		},
		message: { type: 'string' },
	},
	required: ['success', 'error', 'message'],
	additionalProperties: true,
};

/**
 * Combined JSON Schema for all possible Game Service responses.
 * Uses JSON Schema's oneOf for discriminated union based on the `success` field.
 *
 * @example
 * ```typescript
 * const response = await gameService.createGame(input);
 * if (response.success) {
 *   // TypeScript knows this is CreateGameSuccessDto
 *   console.log(response.gameId);
 * } else {
 *   // TypeScript knows this is CreateGameErrorDto
 *   console.error(response.error, response.message);
 * }
 * ```
 */
const CreateGameResponseSchema = {
	oneOf: [CreateGameSuccessSchema, CreateGameErrorSchema],
};

/**
 * Input DTO for creating a new game.
 * This defines the payload structure sent to the Game Service.
 */
export interface CreateGameInput {
	/**
	 * Unique identifier for the game session.
	 * Generated by the Matchmaking Service.
	 * Format can be UUID or custom (e.g., "match-{uuid}", "game-{timestamp}").
	 */
	gameId: string;

	/**
	 * User ID of the first player.
	 * Comes from the Matchmaking Service after match confirmation.
	 * String representation of the numeric Auth Service user ID.
	 */
	player1Id: string;

	/**
	 * User ID of the second player.
	 * Comes from the Matchmaking Service after match confirmation.
	 * String representation of the numeric Auth Service user ID.
	 */
	player2Id: string;
}

// =============================================================================
// GAME SERVICE
// =============================================================================

/**
 * Service responsible for inter-service communication with the Game Service.
 *
 * This service encapsulates all HTTP calls to the Game Service, providing:
 * - Type-safe request/response handling via Zod schemas
 * - Automatic retry and fallback mechanisms via @Resilient decorator
 * - Response validation via @ValidateResult decorator
 * - Centralized logging for debugging and monitoring
 *
 * @remarks
 * ## Architecture Notes
 *
 * The GameService follows the same pattern as UserService for consistency:
 * 1. Public method (`createGame`) provides a clean API for consumers
 * 2. Protected method (`createGameRequest`) handles the actual HTTP call
 * 3. Decorators are applied in specific order for proper error handling
 *
 * ## Decorator Order (IMPORTANT)
 *
 * The decorator order matters for proper error handling:
 * 1. `@Resilient` (outer) - Catches network errors OR validation errors
 * 2. `@ValidateResult` (inner) - Validates response data, throws if invalid
 *
 * This order ensures that validation failures trigger the fallback mechanism.
 *
 * ## Environment Variables
 *
 * - `GAME_SERVICE_URL`: Base URL of the Game Service (e.g., http://game:3000)
 *
 * @example
 * ```typescript
 * // Inject the service
 * constructor(@Inject(GameService) private gameService: GameService) {}
 *
 * // Create a game after match confirmation
 * const result = await this.gameService.createGame({
 *   gameId: randomUUID(),
 *   player1Id: '123',
 *   player2Id: '456',
 * });
 *
 * if (result.success) {
 *   // TypeScript narrows to CreateGameSuccessDto
 *   console.log(`Game ${result.gameId} created!`);
 * } else {
 *   // TypeScript narrows to CreateGameErrorDto
 *   console.error(`Error: ${result.error} - ${result.message}`);
 * }
 * ```
 *
 * @see UserService - Similar service for user data retrieval
 * @see MatchmakingService.finalizeMatch - Primary consumer of this service
 */
@Service()
export class GameService {
	/**
	 * Base URL for the Game Service.
	 * Configured via GAME_SERVICE_URL environment variable.
	 *
	 * @remarks
	 * In Docker/Kubernetes, this typically points to the service name (e.g., http://game:3000).
	 * In local development, it defaults to localhost with a different port.
	 */
	private readonly gameServiceUrl = process.env.GAME_SERVICE_URL;

	/**
	 * Creates a new game session in the Game Service.
	 *
	 * This is the public entry point for creating games. It delegates to the
	 * protected `createGameRequest` method which handles the actual HTTP call
	 * with resilience patterns.
	 *
	 * @param input - Game creation parameters
	 * @param input.gameId - Unique identifier for the game
	 * @param input.player1Id - First player's user ID
	 * @param input.player2Id - Second player's user ID
	 *
	 * @returns Promise resolving to the creation result (success or error)
	 *
	 * @throws Never throws - Errors are caught by @Resilient and return a fallback
	 *
	 * @example
	 * ```typescript
	 * const result = await gameService.createGame({
	 *   gameId: randomUUID(),
	 *   player1Id: '123',
	 *   player2Id: '456',
	 * });
	 *
	 * if (result.success) {
	 *   console.log(`Game ${result.gameId} created!`);
	 * } else {
	 *   console.error(`Failed: ${result.error} - ${result.message}`);
	 * }
	 * ```
	 */
	public async createGame(input: CreateGameInput): Promise<CreateGameResponseDto> {
		return this.createGameRequest(input);
	}

	/**
	 * Internal method performing the actual HTTP POST request to the Game Service.
	 *
	 * ## Decorator Execution Order (Top to Bottom = Outer to Inner)
	 *
	 * 1. **@Resilient** (Outer): Wraps everything in try/catch with timeout
	 *    - Catches network errors (ECONNREFUSED, timeouts, etc.)
	 *    - Catches validation errors thrown by @ValidateResult
	 *    - Returns fallback value on any error
	 *
	 * 2. **@ValidateResult** (Inner): Validates the response against schema
	 *    - Runs AFTER the HTTP call succeeds
	 *    - Throws if response doesn't match CreateGameResponseSchema
	 *    - The thrown error is caught by @Resilient
	 *
	 * @param input - Game creation parameters
	 * @returns Promise resolving to validated response (success or error)
	 *
	 * @remarks
	 * The fallback returns `success: false` with error code 'GAME_ALREADY_EXISTS'
	 * to indicate the game wasn't created due to a service communication issue.
	 * The caller (MatchmakingService) should handle this gracefully, possibly
	 * by retrying or notifying players of the failure.
	 *
	 * The timeout is set to 3 seconds as game creation should be fast.
	 * If the Game Service is slow/down, we prefer failing fast with a fallback.
	 */
	@Resilient<CreateGameResponseDto>({
		context: 'GameService',
		timeoutMs: 3000,
		// Static fallback value - matches CreateGameErrorDto structure
		// The caller should check `success: false` and handle the failure appropriately
		fallback: {
			success: false as const,
			error: 'GAME_ALREADY_EXISTS' as const,
			message: 'Failed to reach Game Service - fallback response',
		},
		logAsError: true, // Game creation failures are critical
	})
	@ValidateResult(CreateGameResponseSchema)
	protected async createGameRequest(input: CreateGameInput): Promise<CreateGameResponseDto> {
		// Endpoint: POST /games (as defined in GameController)
		const targetUrl = `${this.gameServiceUrl}/games`;

		console.info(
			`[GameService] [createGameRequest] POST ${targetUrl} | ` +
				`GameId: ${input.gameId} | P1: ${input.player1Id} | P2: ${input.player2Id}`,
		);

		const response = await fetch(targetUrl, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				// Note: For internal service-to-service calls, we might want to add
				// an internal API key or service token here in production.
				// 'X-Internal-Service': 'matchmaking'
			},
			body: JSON.stringify({
				gameId: input.gameId,
				player1Id: input.player1Id,
				player2Id: input.player2Id,
			}),
		});

		// Handle HTTP status codes:
		// - 201 Created: Game created successfully -> parse JSON body
		// - 409 Conflict: Game creation failed (valid business error) -> parse JSON body
		// - Other errors: Network/server issues -> throw to trigger fallback
		if (response.status === 201 || response.status === 409) {
			// Both success and conflict responses have valid JSON bodies
			// @ValidateResult will validate the structure against our schema
			const data = (await response.json()) as CreateGameResponseDto;

			if (data.success) {
				console.info(`[GameService] [createGameRequest] Game created | GameId: ${data.gameId}`);
			} else {
				console.warn(
					`[GameService] [createGameRequest] Game creation failed | ` +
						`Error: ${data.error} | Message: ${data.message}`,
				);
			}

			return data;
		}

		// Handle unexpected HTTP errors (5xx, 4xx other than 409)
		const errorBody = await response.text().catch(() => 'Unable to read response body');
		const errorMessage = `HTTP Error ${response.status}: ${response.statusText} | Body: ${errorBody}`;

		console.error(`[GameService] [createGameRequest] ${errorMessage}`);
		throw new Error(errorMessage);
	}

	/**
	 * Health check method to verify Game Service connectivity.
	 *
	 * Useful for debugging and monitoring service mesh health.
	 *
	 * @returns Promise resolving to true if Game Service is reachable
	 *
	 * @example
	 * ```typescript
	 * const isHealthy = await gameService.isHealthy();
	 * console.log(`Game Service status: ${isHealthy ? 'UP' : 'DOWN'}`);
	 * ```
	 */
	public async isHealthy(): Promise<boolean> {
		try {
			const response = await fetch(`${this.gameServiceUrl}/health`, {
				method: 'GET',
				signal: AbortSignal.timeout(2000), // 2 second timeout for health checks
			});
			return response.ok;
		} catch (error) {
			console.warn(`[GameService] [isHealthy] Game Service unreachable: ${error}`);
			return false;
		}
	}
}
