import 'reflect-metadata'; // Toujours en premier
import { describe, it, expect, beforeAll, afterAll, afterEach, jest } from '@jest/globals';
import Fastify, { type FastifyInstance } from 'fastify';
import { bootstrap } from 'my-fastify-decorators';
import { io as Client, type Socket as ClientSocket } from 'socket.io-client';
import jwt from 'jsonwebtoken';
import { AddressInfo } from 'net';

// Import plugins
import socketPlugin from '../plugins/socket-plugin.js';
import sqlitePlugin from '../plugins/sqlite-plugin.js';

// --- IMPORT DU VRAI MODULE ---
// Au lieu de définir une classe TestMatchmakingModule, on utilise celle de l'app.
import { MatchmakingModule } from './matchmaking.module.js';
import { UserService } from './user.service.js';

const TEST_SECRET = 'super-secret-test-key';

describe('Matchmaking Integration Test Suite', () => {
	let app: FastifyInstance;
	let serverPort: number;
	let serverUrl: string;
	let activeClients: ClientSocket[] = [];

	// On espionne le prototype pour que l'instance créée par le module réel soit affectée
	const getUserEloSpy = jest.spyOn(UserService.prototype, 'getUserElo');

	/**
	 * Helper function to generate valid JWT tokens for testing.
	 *
	 * The token payload matches the structure generated by the Auth Service:
	 * - `id`: Numeric user identifier (primary key from auth database)
	 * - `email`: User's email address
	 * - `username`: User's display name
	 * - `provider`: Authentication provider (email, github, discord, etc.)
	 *
	 * @param userId - Numeric user ID (will be used as `id` in the JWT payload)
	 * @param email - User's email address (defaults to test@example.com)
	 * @param username - User's display name (defaults to 'testuser')
	 * @returns Signed JWT token string
	 *
	 * @see apps/auth/src/auth/auth.service.ts - generateTokens() for reference
	 * @see apps/matchmaking/src/matchmaking/types.ts - JwtPayload interface
	 */
	const createToken = (
		userId: number,
		email: string = 'test@example.com',
		username: string = 'testuser',
	) => {
		return jwt.sign({ id: userId, email, username, provider: 'email' }, TEST_SECRET);
	};

	const connectClient = (token: string): ClientSocket => {
		const socket = Client(serverUrl, {
			auth: { token },
			transports: ['websocket'],
			forceNew: true,
			autoConnect: true,
		});
		activeClients.push(socket);
		return socket;
	};

	// --- Phase de Démarrage ---
	beforeAll(async () => {
		console.debug('[TEST] [Setup] Initializing Fastify server...');

		app = Fastify({
			logger: {
				transport: {
					target: 'pino-pretty',
					options: {
						colorize: true,
						translateTime: 'HH:MM:ss Z',
						ignore: 'pid,hostname',
					},
				},
			},
		});

		// ==========================================================
		// CORRECTION ICI : Enregistrement des plugins d'infrastructure
		// ==========================================================

		// 1. On enregistre SQLite pour que 'app.db' existe
		await app.register(sqlitePlugin);

		// 2. On enregistre Socket.IO
		await app.register(socketPlugin);

		// 3. IMPORTANT : On attend que Fastify charge ces plugins
		await app.after();

		// 4. Simulation JWT (inchangé)
		app.decorateRequest('user', null);
		app.addHook('preValidation', async (req) => {
			const authHeader = req.headers.authorization;
			if (authHeader && authHeader.startsWith('Bearer ')) {
				const token = authHeader.split(' ')[1];
				try {
					(req as any).user = jwt.verify(token, TEST_SECRET);
				} catch (e) {}
			}
		});

		// 5. Bootstrap du module
		// Maintenant, quand le repository va s'initialiser, 'app.db' sera disponible
		await bootstrap(app, MatchmakingModule);

		// 6. Démarrage serveur
		await app.ready();
		await app.listen({ port: 0, host: '127.0.0.1' });

		const address = app.server.address() as AddressInfo;
		serverPort = address.port;
		serverUrl = `http://127.0.0.1:${serverPort}`;

		console.debug(`[TEST] [Setup] Server listening on ${serverUrl}`);
	});

	// --- Phase de Nettoyage ---
	afterEach(() => {
		activeClients.forEach((socket) => {
			if (socket.connected) socket.disconnect();
		});
		activeClients = [];
		jest.clearAllMocks();
	});

	afterAll(async () => {
		await app.close();
	});

	// ===========================================================================
	// TEST 1 : Vérification de la santé du service (REST)
	// ===========================================================================
	it('should return 200 OK on /matchmaking/health', async () => {
		const response = await app.inject({
			method: 'GET',
			url: '/matchmaking/health',
		});
		expect(response.statusCode).toBe(200);
		const body = JSON.parse(response.payload);
		expect(body.status).toBe('ok');
	});

	// ===========================================================================
	// TEST 2 : Flux WebSocket Nominal
	// Tests the complete flow: connection -> queue join -> verification
	// ===========================================================================
	it('should allow a user to connect and join the queue', (done) => {
		// Use numeric ID to match Auth Service JWT payload format
		const userId = 123;
		const userElo = 1500;
		getUserEloSpy.mockResolvedValue(userElo);

		const token = createToken(userId, 'test@example.com');
		const socket = connectClient(token);

		socket.on('connect_error', (err) => done(err));

		socket.on('connect', () => {
			socket.emit('join_queue', { elo: userElo });
		});

		socket.on('queue_joined', async (data) => {
			try {
				// The gateway converts numeric ID to string for internal use
				expect(data.userId).toBe(String(userId));
				expect(data.elo).toBe(userElo);

				const queueResponse = await app.inject({
					method: 'GET',
					url: '/matchmaking/queue',
				});

				const stats = JSON.parse(queueResponse.payload);
				expect(stats.size).toBe(1);
				done();
			} catch (err) {
				done(err);
			}
		});
	});

	// ===========================================================================
	// TEST 3 : Validation Zod (Payload Invalide)
	// Verifies that invalid payloads are rejected with proper error messages
	// ===========================================================================
	it('should reject invalid payloads with an error event', (done) => {
		getUserEloSpy.mockResolvedValue(1000);
		// Use numeric ID (negative Elo will be tested, not the user ID)
		const token = createToken(999, 'fail@example.com');
		const socket = connectClient(token);

		socket.on('connect', () => {
			// Send invalid negative Elo value
			socket.emit('join_queue', { elo: -50 });
		});

		socket.on('error', (err) => {
			try {
				expect(err).toBeDefined();
				// Flexible error message verification
				if (err.message) {
					expect(err.message).toMatch(/(Invalid|payload)/i);
				}
				done();
			} catch (error) {
				done(error);
			}
		});
	});

	// ===========================================================================
	// TEST 4 : Nettoyage automatique à la déconnexion
	// Ensures players are removed from queue when they disconnect
	// ===========================================================================
	it('should remove player from queue upon disconnection', (done) => {
		getUserEloSpy.mockResolvedValue(1200);
		// Use numeric ID matching Auth Service format
		const token = createToken(456, 'leaver@example.com');
		const socket = connectClient(token);

		socket.on('connect', () => {
			socket.emit('join_queue', { elo: 1200 });
		});

		socket.on('queue_joined', async () => {
			socket.disconnect();

			// Small delay to let the server process the disconnection
			await new Promise((resolve) => setTimeout(resolve, 300));

			const response = await app.inject({
				method: 'GET',
				url: '/matchmaking/queue',
			});

			try {
				const stats = JSON.parse(response.payload);
				expect(stats.size).toBe(0);
				done();
			} catch (err) {
				done(err);
			}
		});
	});

	// ===========================================================================
	// TEST 5 : Quitter la file manuellement
	// Tests voluntary queue leaving functionality
	// ===========================================================================
	it('should allow a user to leave the queue manually', (done) => {
		const userId = 789;
		getUserEloSpy.mockResolvedValue(1300);
		const client = connectClient(createToken(userId));

		client.on('connect', () => {
			client.emit('join_queue', { elo: 1300 });
		});

		client.on('queue_joined', () => {
			// Once in queue, request to leave
			client.emit('leave_queue');
		});

		client.on('queue_left', async (data) => {
			try {
				// ID is converted to string internally
				expect(data.userId).toBe(String(userId));

				// Server-side verification that queue is empty
				const response = await app.inject({
					method: 'GET',
					url: '/matchmaking/queue',
				});
				const stats = JSON.parse(response.payload);
				expect(stats.size).toBe(0);

				done();
			} catch (err) {
				done(err);
			}
		});
	});

	// ===========================================================================
	// TEST 6 : Gestion de l'erreur "Déjà dans la file"
	// Tests duplicate queue join prevention
	// ===========================================================================
	it('should return an error if user tries to join queue twice', (done) => {
		getUserEloSpy.mockResolvedValue(1400);
		const client = connectClient(createToken(1001));

		client.on('connect', () => {
			client.emit('join_queue', { elo: 1400 });
		});

		client.on('queue_joined', () => {
			// Attempt to join a second time
			client.emit('join_queue', { elo: 1400 });
		});

		// We expect an error for the second attempt
		client.on('error', (err) => {
			try {
				expect(err).toBeDefined();
				// Message depends on MatchmakingService implementation
				// Should contain something like "already in queue"
				expect(err.message).toMatch(/(already|exist|queue)/i);
				done();
			} catch (e) {
				done(e);
			}
		});
	});

	// ===========================================================================
	// TEST 7 : Refus de connexion si le UserService échoue
	// Tests that connection is rejected when UserService is unavailable
	// ===========================================================================
	it('should disconnect client if user data cannot be loaded', (done) => {
		// Simulate a critical error from UserService
		getUserEloSpy.mockRejectedValue(new Error('Database connection failed'));

		// Use numeric ID matching Auth Service format
		const client = connectClient(createToken(9999));

		// We listen for disconnection - this is the expected success
		client.once('disconnect', (reason) => {
			try {
				expect(reason).toBe('io server disconnect');
				done();
			} catch (e) {
				done(e);
			}
		});
	});
});
